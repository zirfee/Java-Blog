 hash值
 
 文件的hash值相当于文件的"指纹",是根据文件内容经过复杂算法计算出的文件的摘要,一般认为hash值是唯一的
       为理解原理,设计一个简单的hash算法: 根据文件的值取8的模为hash值 (为了直观用十进制表示)
		         108%8=4
					   109%8=5
						 110%8=6
						 111%8=7
						 112%8=0
						 116%8=4
		 如果文件只有108--112,自然可以用计算后的hash值代表数据本身如用4代表"108",但如果文件增多,有了116,就会发现116的hash值和108一样
		 如果出现这样的情况,就说明该算法不可靠,毕竟hash是指纹,要求"唯一".
		 该算法的得到的文件hash值最多有8个,即0--7,这表明一共就有8个指纹,最多也就能加密8个文件,如果有九个不同的文件,加密到第九个时必然会出现hash值
		 相同的情况,事实加密到第五个时就有50%的几率hash值一样了
		 
		 现在的sha2-256 hash算法能计算出256位的hash值,也就是有2^256个指纹,这就意味则在这种算法下想要找到两种hash值相同的文件,确保找到就要尝试2^256
		 +1个不同文件,几乎不可能,之前的MD5,sha1等算法已经被证明可以花费较小的代价破解,所以不建议使用了
		 
		 java集合框架
		 
		     顶层为collection接口,该接口实现了iterator迭代器接口
				 
				 collection有很多抽象方法,如果想要自定义一个collection,实现接口就必须实现全部方法,很不方便,
				 所以有一个抽象类abstractCollection,该类部分实现了一些常用方法,保留了如iterator()这种抽象方法
				 所以自定义一个集合类就可以继承abstractCollection,不必实现全部方法,但必须实现抽象方法,
				 jdk1.8之后完全可以在collection接口中定义default方法,该方法可以有方法体,不必再提供伴随类
				 
				 Ierator迭代器可以看作集合框架的通用指针,框架本身不能对指针进行操作,想要移动指针实现集合遍历等常用操作
				 必须由iterator完成,iterator不指向元素,而是指向元素之间的间隔.iterator有三个方法,hasNext(),next(),remove(),只有这三个方法.hasNext()判断是否有
				 下一对象,next()返回下一个对象,并向下移动一位指针,指针默认指向第一个对象之前.remove()移除当前指针的上一个对象
				 
				 collection下有list set queue
				 
				 list 实现了iterator的子接口ListIterator除基本接口的next(),hasnext(),remove()功能外,增加了previous,hasPrevious等向前遍历的操作,还有add()
				 方法(只用在list),位置同remove()
		     
				 
		    
				 
		 

		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
