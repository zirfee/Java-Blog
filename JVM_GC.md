#### 垃圾回收
   
   垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收
   无任何对象引用的对象占据的内存空间的一种机制。
		 
		 
#### 分析

- 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。（引用都有哪些？对垃圾回收又有什么影响？）

- 垃圾：无任何对象引用的对象（怎么通过算法找到这些对象呢？）。

- 回收：清理“垃圾”占用的内存空间而非对象本身（怎么通过算法实现回收呢？）。

- 发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中（堆内存为了配合垃圾回收有什么不同区域划分，各区域有什么不同？）。

- 发生时间：程序空闲时间不定时回收（回收的执行机制是什么？是否可以通过显示调用函数的方式来确定的进行回收过程？）

#### 引用

- 强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

- 软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。

- 弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。

- 虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。

#### 判断垃圾算法

Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：

(1）找到所有存活对象；

(2) 回收被无用对象占用的内存空间，使该空间可被程序再次使用。
	
- 引用计数算法

  所有实例化对象给与一个计数器,每当被引用时计数器+1;失去引用时计数器-1;计数器为0时被回收
  难以处理两个对象循环调用的问题,对程序性能影响大,java不采用此算法
	   
- 根搜索算法

 java使用此算法

#### 回收垃圾占用内存算法

标记—清除算法

标记—整理算法

Copying算法

Adaptive算法

	  
#### 堆内存区域划分   (full GC)

新生代   (minor GC)  GC频繁   
  
年老代    (major GC)  GC很少

持久代(分为eden和survivor区)
	  
java利用new产生的对象放在堆中,基于对象生命周期的不同,将不同对象放在不同代的区域中,每个区域用不同算法处理

- 新生代
        
   几乎所有新生成的对象都放在此区域;按照8:1:1分为eden区和survivor0,survivor1;首先放在eden区,eden区满后启动GC机制清理垃圾对象
   清理后存活对象放在survivor1区,然后清空eden区,一段时间后survivor0会满,此时GC后把存活对象放入survivor1中,清空eden和survivor0
   交换survivor0和survivor1保持survivor1为空;若干时间后suivivor1慢,将存活对象放入老年代		
   当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中

- 老年代
	      
   在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)
    大对象会被直接分配到老年代,如大数组   
	  
- 持久代
	    
   存放静态文件（class类、方法）和常量等
		 
		 
> 注意:
  
> (1) 对象优先在Eden分配。
  
> (2) 大对象直接进入老年代。

> (3) 长期存活的对象将进入老年代。
		 
 #### 与垃圾回收有关的两个函数
 
- System.gc()方法

调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，
使垃圾回收操作容易发生，或提早发生，或回收较多而已
            
- finalize()方法

此方法用于垃圾回收前 释放无用对象的资源
之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象没有使用new方法,而是用C/C++方法的malloc()函数获得了一块“特殊”的内存区域，
由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候Java允许在类中定义一个finalize()方法
来处理
             
#### 触发GC条件

 1)当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。

 2)Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。
   若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。
  
 3）在编译过程中作为一种优化技术，Java 编译器能选择给实例赋 null 值，从而标记实例为可回收。


#### 减少GC开销的措施

(1)不要显式调用System.gc()

   此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。

(2)尽量减少临时对象的使用
 
   临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。

(3)对象不用时最好显式置为Null

   一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。

(4)尽量使用StringBuffer,而不用String来累加字符串

   由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。

(5)能用基本类型如Int,Long,就不用Integer,Long对象

   基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。

(6)尽量少用静态对象变量

    静态变量属于全局变量,不会被GC回收,它们会一直占用内存。

(7)分散对象创建或删除的时间

    集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。

#### 代码分析垃圾回收过程

	public class SlotGc{
	  public static void main(String[] args){
	    byte[] holder = new byte[32*1024*1024];
		System.gc();
      }
	}
   

代码很简单，就是向内存中填充了32MB的数据，然后通过虚拟机进行垃圾收集。在Javac编译后，在终端执行如下指令：java -verbose:gc SlotGc来查看垃圾收集的结果，得到如下输出信息：

     [GC 208K->134K(5056K), 0.0017306 secs]

     [Full GC 134K->134K(5056K), 0.0121194 secs]

     [Full GC 32902K->32902K(37828K), 0.0094149 sec]


  注意第三行，“->”之前的数据表示垃圾回收前堆中存活对象所占用的内存大小，“->”之后的数据表示垃圾回收堆中存活对象所占用的内存大小，括号中的数据表示堆内存的总容量，0.0094149 sec 表示垃圾回收所用的时间。

  从结果中可以看出，System.gc(（）运行后并没有回收掉这32MB的内存，这应该是意料之中的结果，因为变量holder还处在作用域内，虚拟机自然不会回收掉holder引用的对象所占用的内存。

修改代码如下：

	public class SlotGc{
     public static void main(String[] args){
	   {
	    byte[] holder = new byte[32*1024*1024];
		}
        System.gc();
     }
    }
   

  加入花括号后，holder的作用域被限制在了花括号之内，因此，在执行System.gc（）时，holder引用已经不能再被访问，逻辑上来讲，这次应该会回收掉holder引用的对象所占的内存。但查看垃圾回收情况时，输出信息如下：

             [GC 208K->134K(5056K), 0.0017100 secs]

              [Full GC 134K->134K(5056K), 0.0125887 secs]

              [Full GC 32902K->32902K(37828K), 0.0089226 secs]

  很明显，这32MB的数据并没有被回收。下面我们再做如下修改：

	 public class SlotGc{
	 	public static void main(String[] args){
		 {
		   byte[] holder = new byte[32*1024*1024];
		   holder = null;
		 }
		 System.gc();
       }    
	 }
	 
这次得到的垃圾回收信息如下：

               [GC 208K->134K(5056K), 0.0017194 secs]

               [Full GC 134K->134K(5056K), 0.0124656 secs]

               [Full GC 32902K->134K(37828K), 0.0091637 secs]

说明这次holder引用的对象所占的内存被回收了。

  首先明确一点：holder能否被回收的根本原因是局部变量表中的Slot是否还存有关于holder数组对象的引用。

  在第一次修改中，虽然在holder作用域之外进行回收，但是在此之后，没有对局部变量表的读写操作，holder所占用的Slot还没有被其他变量所复用。所以作为GC Roots一部分的局部变量表仍保持者对它的关联。这种关联没有被及时打断，因此GC收集器不会将holder引用的对象内存回收掉。 在第二次修改中，在GC收集器工作前，手动将holder设置为null值，就把holder所占用的局部变量表中的Slot清空了，因此，这次GC收集器工作时将holder之前引用的对象内存回收掉了。

 当然，我们也可以用其他方法来将holder引用的对象内存回收掉，只要复用holder所占用的slot即可，比如在holder作用域之外执行一次读写操作。

 为对象赋null值并不是控制变量回收的最好方法，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法。另外，赋null值的操作在经过虚拟机JIT编译器优化后会被消除掉，经过JIT编译后，System.gc（）执行时就可以正确地回收掉内存，而无需赋null值。

 

								  
**jvm调优**主要调整堆内存分配,以及垃圾收集器性能调整

1.性能调优原则
         
  1). MinorGC回收原则： 每次minor GC 都要尽可能多的收集垃圾对象。以减少应用程序发生Full GC的频率。
  
  2). GC内存最大化原则：处理吞吐量和延迟问题时候，垃圾处理器能使用的内存越大，垃圾收集的效果越好，应用程序也会越来越流畅。
		 
  3). GC调优3选2原则: 在性能属性里面，吞吐量、延迟、内存占用，我们只能选择其中两个进行调优，不可三者兼得。

2.调内存

  计算活跃数据大小  指应用程序稳定阶段时，观察长期存活的对象在java堆中占用的空间大小。
  测试时，启动参数采用jvm默认参数，不人为设置。

  确保Full GC 发生时，应用程序正处于稳定阶段。

  观察full GC日志
		
  根据需求设定堆内存中各代区域大小
			
3.调延迟

  延迟指标
   
  1). 应用程序可接受的平均停滞时间: 此时间与测量的Minor GC持续时间进行比较。
		  
  2). 可接受的Minor GC频率：Minor GC的频率与可容忍的值进行比较。
		  
  3). 可接受的最大停顿时间: 最大停顿时间与最差情况下FullGC的持续时间进行比较。
		  
  4). 可接受的最大停顿发生的频率：基本就是FullGC的频率。
		  
  5). 最影响用户体验的是平均停止时间和最大停顿时间
		  
  6). 如果延迟跟预想差别较大;可以退回到上一步重新调整内存大小
		  
4.调整吞吐量

应用程序应该有一个综合的吞吐指标，这个指标基于真个应用的需求和测试而衍生出来的。
当有应用程序的吞吐量达到或者超过预期的吞吐目标，整个调优过程就可以圆满结束了。
		
如果出现调优后依然无法达到应用程序的吞吐目标，需要重新回顾吞吐要求，评估当前吞吐量和目标差距是否巨大，
如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。
		 
对于垃圾收集器来说，提升吞吐量的性能调优的目标就是就是尽可能避免或者很少发生FullGC 或者Stop-The-World压缩式垃圾收集（CMS），
因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。

### 内存泄露

 （1）静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。

      Static Vector v = new Vector();
        for (int i = 1; i<100; i++){
            Object o = new Object();
              v.add(o);
		      o = null;
          }

在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，
如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，
就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后，
Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。

 （2）各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。

 （3）监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。


		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  






